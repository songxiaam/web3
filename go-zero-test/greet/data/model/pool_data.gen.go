// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"greet/data/model"
)

func newPoolDatum(db *gorm.DB, opts ...gen.DOOption) poolDatum {
	_poolDatum := poolDatum{}

	_poolDatum.poolDatumDo.UseDB(db, opts...)
	_poolDatum.poolDatumDo.UseModel(&model.PoolDatum{})

	tableName := _poolDatum.poolDatumDo.TableName()
	_poolDatum.ALL = field.NewAsterisk(tableName)
	_poolDatum.SettleAmountLend = field.NewString(tableName, "settle_amount_lend")
	_poolDatum.SettleAmountBorrow = field.NewString(tableName, "settle_amount_borrow")
	_poolDatum.FinishAmountLend = field.NewString(tableName, "finish_amount_lend")
	_poolDatum.FinishAmountBorrow = field.NewString(tableName, "finish_amount_borrow")
	_poolDatum.LiquidationAmounLend = field.NewString(tableName, "liquidation_amoun_lend")
	_poolDatum.LiquidationAmounBorrow = field.NewString(tableName, "liquidation_amoun_borrow")
	_poolDatum.UpdatedAt = field.NewTime(tableName, "updated_at")
	_poolDatum.CreatedAt = field.NewTime(tableName, "created_at")
	_poolDatum.ID = field.NewInt32(tableName, "id")
	_poolDatum.ChainID = field.NewString(tableName, "chain_id")
	_poolDatum.PoolID = field.NewString(tableName, "pool_id")

	_poolDatum.fillFieldMap()

	return _poolDatum
}

// poolDatum pooldata
type poolDatum struct {
	poolDatumDo

	ALL                    field.Asterisk
	SettleAmountLend       field.String
	SettleAmountBorrow     field.String
	FinishAmountLend       field.String
	FinishAmountBorrow     field.String
	LiquidationAmounLend   field.String
	LiquidationAmounBorrow field.String
	UpdatedAt              field.Time
	CreatedAt              field.Time
	ID                     field.Int32
	ChainID                field.String
	PoolID                 field.String

	fieldMap map[string]field.Expr
}

func (p poolDatum) Table(newTableName string) *poolDatum {
	p.poolDatumDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p poolDatum) As(alias string) *poolDatum {
	p.poolDatumDo.DO = *(p.poolDatumDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *poolDatum) updateTableName(table string) *poolDatum {
	p.ALL = field.NewAsterisk(table)
	p.SettleAmountLend = field.NewString(table, "settle_amount_lend")
	p.SettleAmountBorrow = field.NewString(table, "settle_amount_borrow")
	p.FinishAmountLend = field.NewString(table, "finish_amount_lend")
	p.FinishAmountBorrow = field.NewString(table, "finish_amount_borrow")
	p.LiquidationAmounLend = field.NewString(table, "liquidation_amoun_lend")
	p.LiquidationAmounBorrow = field.NewString(table, "liquidation_amoun_borrow")
	p.UpdatedAt = field.NewTime(table, "updated_at")
	p.CreatedAt = field.NewTime(table, "created_at")
	p.ID = field.NewInt32(table, "id")
	p.ChainID = field.NewString(table, "chain_id")
	p.PoolID = field.NewString(table, "pool_id")

	p.fillFieldMap()

	return p
}

func (p *poolDatum) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *poolDatum) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 11)
	p.fieldMap["settle_amount_lend"] = p.SettleAmountLend
	p.fieldMap["settle_amount_borrow"] = p.SettleAmountBorrow
	p.fieldMap["finish_amount_lend"] = p.FinishAmountLend
	p.fieldMap["finish_amount_borrow"] = p.FinishAmountBorrow
	p.fieldMap["liquidation_amoun_lend"] = p.LiquidationAmounLend
	p.fieldMap["liquidation_amoun_borrow"] = p.LiquidationAmounBorrow
	p.fieldMap["updated_at"] = p.UpdatedAt
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["id"] = p.ID
	p.fieldMap["chain_id"] = p.ChainID
	p.fieldMap["pool_id"] = p.PoolID
}

func (p poolDatum) clone(db *gorm.DB) poolDatum {
	p.poolDatumDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p poolDatum) replaceDB(db *gorm.DB) poolDatum {
	p.poolDatumDo.ReplaceDB(db)
	return p
}

type poolDatumDo struct{ gen.DO }

type IPoolDatumDo interface {
	gen.SubQuery
	Debug() IPoolDatumDo
	WithContext(ctx context.Context) IPoolDatumDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPoolDatumDo
	WriteDB() IPoolDatumDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPoolDatumDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPoolDatumDo
	Not(conds ...gen.Condition) IPoolDatumDo
	Or(conds ...gen.Condition) IPoolDatumDo
	Select(conds ...field.Expr) IPoolDatumDo
	Where(conds ...gen.Condition) IPoolDatumDo
	Order(conds ...field.Expr) IPoolDatumDo
	Distinct(cols ...field.Expr) IPoolDatumDo
	Omit(cols ...field.Expr) IPoolDatumDo
	Join(table schema.Tabler, on ...field.Expr) IPoolDatumDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPoolDatumDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPoolDatumDo
	Group(cols ...field.Expr) IPoolDatumDo
	Having(conds ...gen.Condition) IPoolDatumDo
	Limit(limit int) IPoolDatumDo
	Offset(offset int) IPoolDatumDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPoolDatumDo
	Unscoped() IPoolDatumDo
	Create(values ...*model.PoolDatum) error
	CreateInBatches(values []*model.PoolDatum, batchSize int) error
	Save(values ...*model.PoolDatum) error
	First() (*model.PoolDatum, error)
	Take() (*model.PoolDatum, error)
	Last() (*model.PoolDatum, error)
	Find() ([]*model.PoolDatum, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PoolDatum, err error)
	FindInBatches(result *[]*model.PoolDatum, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PoolDatum) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPoolDatumDo
	Assign(attrs ...field.AssignExpr) IPoolDatumDo
	Joins(fields ...field.RelationField) IPoolDatumDo
	Preload(fields ...field.RelationField) IPoolDatumDo
	FirstOrInit() (*model.PoolDatum, error)
	FirstOrCreate() (*model.PoolDatum, error)
	FindByPage(offset int, limit int) (result []*model.PoolDatum, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPoolDatumDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p poolDatumDo) Debug() IPoolDatumDo {
	return p.withDO(p.DO.Debug())
}

func (p poolDatumDo) WithContext(ctx context.Context) IPoolDatumDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p poolDatumDo) ReadDB() IPoolDatumDo {
	return p.Clauses(dbresolver.Read)
}

func (p poolDatumDo) WriteDB() IPoolDatumDo {
	return p.Clauses(dbresolver.Write)
}

func (p poolDatumDo) Session(config *gorm.Session) IPoolDatumDo {
	return p.withDO(p.DO.Session(config))
}

func (p poolDatumDo) Clauses(conds ...clause.Expression) IPoolDatumDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p poolDatumDo) Returning(value interface{}, columns ...string) IPoolDatumDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p poolDatumDo) Not(conds ...gen.Condition) IPoolDatumDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p poolDatumDo) Or(conds ...gen.Condition) IPoolDatumDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p poolDatumDo) Select(conds ...field.Expr) IPoolDatumDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p poolDatumDo) Where(conds ...gen.Condition) IPoolDatumDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p poolDatumDo) Order(conds ...field.Expr) IPoolDatumDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p poolDatumDo) Distinct(cols ...field.Expr) IPoolDatumDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p poolDatumDo) Omit(cols ...field.Expr) IPoolDatumDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p poolDatumDo) Join(table schema.Tabler, on ...field.Expr) IPoolDatumDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p poolDatumDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPoolDatumDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p poolDatumDo) RightJoin(table schema.Tabler, on ...field.Expr) IPoolDatumDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p poolDatumDo) Group(cols ...field.Expr) IPoolDatumDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p poolDatumDo) Having(conds ...gen.Condition) IPoolDatumDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p poolDatumDo) Limit(limit int) IPoolDatumDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p poolDatumDo) Offset(offset int) IPoolDatumDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p poolDatumDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPoolDatumDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p poolDatumDo) Unscoped() IPoolDatumDo {
	return p.withDO(p.DO.Unscoped())
}

func (p poolDatumDo) Create(values ...*model.PoolDatum) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p poolDatumDo) CreateInBatches(values []*model.PoolDatum, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p poolDatumDo) Save(values ...*model.PoolDatum) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p poolDatumDo) First() (*model.PoolDatum, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PoolDatum), nil
	}
}

func (p poolDatumDo) Take() (*model.PoolDatum, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PoolDatum), nil
	}
}

func (p poolDatumDo) Last() (*model.PoolDatum, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PoolDatum), nil
	}
}

func (p poolDatumDo) Find() ([]*model.PoolDatum, error) {
	result, err := p.DO.Find()
	return result.([]*model.PoolDatum), err
}

func (p poolDatumDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PoolDatum, err error) {
	buf := make([]*model.PoolDatum, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p poolDatumDo) FindInBatches(result *[]*model.PoolDatum, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p poolDatumDo) Attrs(attrs ...field.AssignExpr) IPoolDatumDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p poolDatumDo) Assign(attrs ...field.AssignExpr) IPoolDatumDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p poolDatumDo) Joins(fields ...field.RelationField) IPoolDatumDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p poolDatumDo) Preload(fields ...field.RelationField) IPoolDatumDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p poolDatumDo) FirstOrInit() (*model.PoolDatum, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PoolDatum), nil
	}
}

func (p poolDatumDo) FirstOrCreate() (*model.PoolDatum, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PoolDatum), nil
	}
}

func (p poolDatumDo) FindByPage(offset int, limit int) (result []*model.PoolDatum, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p poolDatumDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p poolDatumDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p poolDatumDo) Delete(models ...*model.PoolDatum) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *poolDatumDo) withDO(do gen.Dao) *poolDatumDo {
	p.DO = *do.(*gen.DO)
	return p
}
