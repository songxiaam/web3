// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package metaland

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"greet/data/model"
)

func newComerAccount(db *gorm.DB, opts ...gen.DOOption) comerAccount {
	_comerAccount := comerAccount{}

	_comerAccount.comerAccountDo.UseDB(db, opts...)
	_comerAccount.comerAccountDo.UseModel(&model.ComerAccount{})

	tableName := _comerAccount.comerAccountDo.TableName()
	_comerAccount.ALL = field.NewAsterisk(tableName)
	_comerAccount.ID = field.NewInt64(tableName, "id")
	_comerAccount.ComerID = field.NewInt64(tableName, "comer_id")
	_comerAccount.Oin = field.NewString(tableName, "oin")
	_comerAccount.IsPrimary = field.NewBool(tableName, "is_primary")
	_comerAccount.Nick = field.NewString(tableName, "nick")
	_comerAccount.Avatar = field.NewString(tableName, "avatar")
	_comerAccount.Type = field.NewInt32(tableName, "type")
	_comerAccount.IsLinked = field.NewBool(tableName, "is_linked")
	_comerAccount.CreatedAt = field.NewTime(tableName, "created_at")
	_comerAccount.UpdatedAt = field.NewTime(tableName, "updated_at")
	_comerAccount.IsDeleted = field.NewBool(tableName, "is_deleted")

	_comerAccount.fillFieldMap()

	return _comerAccount
}

type comerAccount struct {
	comerAccountDo

	ALL       field.Asterisk
	ID        field.Int64
	ComerID   field.Int64  // comer unique identifier
	Oin       field.String // comer outer account unique identifier, wallet will be public key and Oauth is the OauthID
	IsPrimary field.Bool   // comer use this account as primay account
	Nick      field.String // comer nick name
	Avatar    field.String // avatar link address
	Type      field.Int32  // 1 for github  2 for google 3 for twitter 4 for facebook 5 for likedin
	IsLinked  field.Bool   // 0 for unlink 1 for linked
	CreatedAt field.Time
	UpdatedAt field.Time
	IsDeleted field.Bool // Is Deleted

	fieldMap map[string]field.Expr
}

func (c comerAccount) Table(newTableName string) *comerAccount {
	c.comerAccountDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c comerAccount) As(alias string) *comerAccount {
	c.comerAccountDo.DO = *(c.comerAccountDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *comerAccount) updateTableName(table string) *comerAccount {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewInt64(table, "id")
	c.ComerID = field.NewInt64(table, "comer_id")
	c.Oin = field.NewString(table, "oin")
	c.IsPrimary = field.NewBool(table, "is_primary")
	c.Nick = field.NewString(table, "nick")
	c.Avatar = field.NewString(table, "avatar")
	c.Type = field.NewInt32(table, "type")
	c.IsLinked = field.NewBool(table, "is_linked")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.IsDeleted = field.NewBool(table, "is_deleted")

	c.fillFieldMap()

	return c
}

func (c *comerAccount) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *comerAccount) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 11)
	c.fieldMap["id"] = c.ID
	c.fieldMap["comer_id"] = c.ComerID
	c.fieldMap["oin"] = c.Oin
	c.fieldMap["is_primary"] = c.IsPrimary
	c.fieldMap["nick"] = c.Nick
	c.fieldMap["avatar"] = c.Avatar
	c.fieldMap["type"] = c.Type
	c.fieldMap["is_linked"] = c.IsLinked
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["is_deleted"] = c.IsDeleted
}

func (c comerAccount) clone(db *gorm.DB) comerAccount {
	c.comerAccountDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c comerAccount) replaceDB(db *gorm.DB) comerAccount {
	c.comerAccountDo.ReplaceDB(db)
	return c
}

type comerAccountDo struct{ gen.DO }

type IComerAccountDo interface {
	gen.SubQuery
	Debug() IComerAccountDo
	WithContext(ctx context.Context) IComerAccountDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IComerAccountDo
	WriteDB() IComerAccountDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IComerAccountDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IComerAccountDo
	Not(conds ...gen.Condition) IComerAccountDo
	Or(conds ...gen.Condition) IComerAccountDo
	Select(conds ...field.Expr) IComerAccountDo
	Where(conds ...gen.Condition) IComerAccountDo
	Order(conds ...field.Expr) IComerAccountDo
	Distinct(cols ...field.Expr) IComerAccountDo
	Omit(cols ...field.Expr) IComerAccountDo
	Join(table schema.Tabler, on ...field.Expr) IComerAccountDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IComerAccountDo
	RightJoin(table schema.Tabler, on ...field.Expr) IComerAccountDo
	Group(cols ...field.Expr) IComerAccountDo
	Having(conds ...gen.Condition) IComerAccountDo
	Limit(limit int) IComerAccountDo
	Offset(offset int) IComerAccountDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IComerAccountDo
	Unscoped() IComerAccountDo
	Create(values ...*model.ComerAccount) error
	CreateInBatches(values []*model.ComerAccount, batchSize int) error
	Save(values ...*model.ComerAccount) error
	First() (*model.ComerAccount, error)
	Take() (*model.ComerAccount, error)
	Last() (*model.ComerAccount, error)
	Find() ([]*model.ComerAccount, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ComerAccount, err error)
	FindInBatches(result *[]*model.ComerAccount, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ComerAccount) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IComerAccountDo
	Assign(attrs ...field.AssignExpr) IComerAccountDo
	Joins(fields ...field.RelationField) IComerAccountDo
	Preload(fields ...field.RelationField) IComerAccountDo
	FirstOrInit() (*model.ComerAccount, error)
	FirstOrCreate() (*model.ComerAccount, error)
	FindByPage(offset int, limit int) (result []*model.ComerAccount, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IComerAccountDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c comerAccountDo) Debug() IComerAccountDo {
	return c.withDO(c.DO.Debug())
}

func (c comerAccountDo) WithContext(ctx context.Context) IComerAccountDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c comerAccountDo) ReadDB() IComerAccountDo {
	return c.Clauses(dbresolver.Read)
}

func (c comerAccountDo) WriteDB() IComerAccountDo {
	return c.Clauses(dbresolver.Write)
}

func (c comerAccountDo) Session(config *gorm.Session) IComerAccountDo {
	return c.withDO(c.DO.Session(config))
}

func (c comerAccountDo) Clauses(conds ...clause.Expression) IComerAccountDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c comerAccountDo) Returning(value interface{}, columns ...string) IComerAccountDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c comerAccountDo) Not(conds ...gen.Condition) IComerAccountDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c comerAccountDo) Or(conds ...gen.Condition) IComerAccountDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c comerAccountDo) Select(conds ...field.Expr) IComerAccountDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c comerAccountDo) Where(conds ...gen.Condition) IComerAccountDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c comerAccountDo) Order(conds ...field.Expr) IComerAccountDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c comerAccountDo) Distinct(cols ...field.Expr) IComerAccountDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c comerAccountDo) Omit(cols ...field.Expr) IComerAccountDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c comerAccountDo) Join(table schema.Tabler, on ...field.Expr) IComerAccountDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c comerAccountDo) LeftJoin(table schema.Tabler, on ...field.Expr) IComerAccountDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c comerAccountDo) RightJoin(table schema.Tabler, on ...field.Expr) IComerAccountDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c comerAccountDo) Group(cols ...field.Expr) IComerAccountDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c comerAccountDo) Having(conds ...gen.Condition) IComerAccountDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c comerAccountDo) Limit(limit int) IComerAccountDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c comerAccountDo) Offset(offset int) IComerAccountDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c comerAccountDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IComerAccountDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c comerAccountDo) Unscoped() IComerAccountDo {
	return c.withDO(c.DO.Unscoped())
}

func (c comerAccountDo) Create(values ...*model.ComerAccount) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c comerAccountDo) CreateInBatches(values []*model.ComerAccount, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c comerAccountDo) Save(values ...*model.ComerAccount) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c comerAccountDo) First() (*model.ComerAccount, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ComerAccount), nil
	}
}

func (c comerAccountDo) Take() (*model.ComerAccount, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ComerAccount), nil
	}
}

func (c comerAccountDo) Last() (*model.ComerAccount, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ComerAccount), nil
	}
}

func (c comerAccountDo) Find() ([]*model.ComerAccount, error) {
	result, err := c.DO.Find()
	return result.([]*model.ComerAccount), err
}

func (c comerAccountDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ComerAccount, err error) {
	buf := make([]*model.ComerAccount, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c comerAccountDo) FindInBatches(result *[]*model.ComerAccount, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c comerAccountDo) Attrs(attrs ...field.AssignExpr) IComerAccountDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c comerAccountDo) Assign(attrs ...field.AssignExpr) IComerAccountDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c comerAccountDo) Joins(fields ...field.RelationField) IComerAccountDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c comerAccountDo) Preload(fields ...field.RelationField) IComerAccountDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c comerAccountDo) FirstOrInit() (*model.ComerAccount, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ComerAccount), nil
	}
}

func (c comerAccountDo) FirstOrCreate() (*model.ComerAccount, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ComerAccount), nil
	}
}

func (c comerAccountDo) FindByPage(offset int, limit int) (result []*model.ComerAccount, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c comerAccountDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c comerAccountDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c comerAccountDo) Delete(models ...*model.ComerAccount) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *comerAccountDo) withDO(do gen.Dao) *comerAccountDo {
	c.DO = *do.(*gen.DO)
	return c
}
