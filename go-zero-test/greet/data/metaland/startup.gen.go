// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package metaland

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"greet/data/model"
)

func newStartup(db *gorm.DB, opts ...gen.DOOption) startup {
	_startup := startup{}

	_startup.startupDo.UseDB(db, opts...)
	_startup.startupDo.UseModel(&model.Startup{})

	tableName := _startup.startupDo.TableName()
	_startup.ALL = field.NewAsterisk(tableName)
	_startup.ID = field.NewInt64(tableName, "id")
	_startup.ComerID = field.NewInt64(tableName, "comer_id")
	_startup.Name = field.NewString(tableName, "name")
	_startup.Mode = field.NewInt32(tableName, "mode")
	_startup.Logo = field.NewString(tableName, "logo")
	_startup.Cover = field.NewString(tableName, "cover")
	_startup.Mission = field.NewString(tableName, "mission")
	_startup.TokenContractAddress = field.NewString(tableName, "token_contract_address")
	_startup.Overview = field.NewString(tableName, "overview")
	_startup.TxHash = field.NewString(tableName, "tx_hash")
	_startup.OnChain = field.NewBool(tableName, "on_chain")
	_startup.Kyc = field.NewString(tableName, "kyc")
	_startup.ContractAudit = field.NewString(tableName, "contract_audit")
	_startup.Website = field.NewString(tableName, "website")
	_startup.Discord = field.NewString(tableName, "discord")
	_startup.Twitter = field.NewString(tableName, "twitter")
	_startup.Telegram = field.NewString(tableName, "telegram")
	_startup.Docs = field.NewString(tableName, "docs")
	_startup.Email = field.NewString(tableName, "email")
	_startup.Facebook = field.NewString(tableName, "facebook")
	_startup.Medium = field.NewString(tableName, "medium")
	_startup.Linktree = field.NewString(tableName, "linktree")
	_startup.LaunchNetwork = field.NewInt32(tableName, "launch_network")
	_startup.TokenName = field.NewString(tableName, "token_name")
	_startup.TokenSymbol = field.NewString(tableName, "token_symbol")
	_startup.TotalSupply = field.NewInt64(tableName, "total_supply")
	_startup.PresaleStart = field.NewTime(tableName, "presale_start")
	_startup.PresaleEnd = field.NewTime(tableName, "presale_end")
	_startup.LaunchDate = field.NewTime(tableName, "launch_date")
	_startup.TabSequence = field.NewString(tableName, "tab_sequence")
	_startup.CreatedAt = field.NewTime(tableName, "created_at")
	_startup.UpdatedAt = field.NewTime(tableName, "updated_at")
	_startup.IsDeleted = field.NewBool(tableName, "is_deleted")

	_startup.fillFieldMap()

	return _startup
}

type startup struct {
	startupDo

	ALL                  field.Asterisk
	ID                   field.Int64
	ComerID              field.Int64  // comer_id
	Name                 field.String // name
	Mode                 field.Int32  // 0:NONE, 1:ESG, 2:NGO, 3:DAO, 4:COM
	Logo                 field.String // logo
	Cover                field.String
	Mission              field.String // logo
	TokenContractAddress field.String // token contract address
	Overview             field.String // overview
	TxHash               field.String
	OnChain              field.Bool   // whether it is on the chain
	Kyc                  field.String // KYC
	ContractAudit        field.String // contract audit
	Website              field.String // website
	Discord              field.String // discord
	Twitter              field.String // twitter
	Telegram             field.String // telegram
	Docs                 field.String // docs
	Email                field.String
	Facebook             field.String
	Medium               field.String
	Linktree             field.String
	LaunchNetwork        field.Int32  // chain id
	TokenName            field.String // token name
	TokenSymbol          field.String // token symbol
	TotalSupply          field.Int64  // total supply
	PresaleStart         field.Time   // presale start date
	PresaleEnd           field.Time   // presale end date
	LaunchDate           field.Time   // launch_date
	TabSequence          field.String
	CreatedAt            field.Time
	UpdatedAt            field.Time
	IsDeleted            field.Bool // Is Deleted

	fieldMap map[string]field.Expr
}

func (s startup) Table(newTableName string) *startup {
	s.startupDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s startup) As(alias string) *startup {
	s.startupDo.DO = *(s.startupDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *startup) updateTableName(table string) *startup {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.ComerID = field.NewInt64(table, "comer_id")
	s.Name = field.NewString(table, "name")
	s.Mode = field.NewInt32(table, "mode")
	s.Logo = field.NewString(table, "logo")
	s.Cover = field.NewString(table, "cover")
	s.Mission = field.NewString(table, "mission")
	s.TokenContractAddress = field.NewString(table, "token_contract_address")
	s.Overview = field.NewString(table, "overview")
	s.TxHash = field.NewString(table, "tx_hash")
	s.OnChain = field.NewBool(table, "on_chain")
	s.Kyc = field.NewString(table, "kyc")
	s.ContractAudit = field.NewString(table, "contract_audit")
	s.Website = field.NewString(table, "website")
	s.Discord = field.NewString(table, "discord")
	s.Twitter = field.NewString(table, "twitter")
	s.Telegram = field.NewString(table, "telegram")
	s.Docs = field.NewString(table, "docs")
	s.Email = field.NewString(table, "email")
	s.Facebook = field.NewString(table, "facebook")
	s.Medium = field.NewString(table, "medium")
	s.Linktree = field.NewString(table, "linktree")
	s.LaunchNetwork = field.NewInt32(table, "launch_network")
	s.TokenName = field.NewString(table, "token_name")
	s.TokenSymbol = field.NewString(table, "token_symbol")
	s.TotalSupply = field.NewInt64(table, "total_supply")
	s.PresaleStart = field.NewTime(table, "presale_start")
	s.PresaleEnd = field.NewTime(table, "presale_end")
	s.LaunchDate = field.NewTime(table, "launch_date")
	s.TabSequence = field.NewString(table, "tab_sequence")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")
	s.IsDeleted = field.NewBool(table, "is_deleted")

	s.fillFieldMap()

	return s
}

func (s *startup) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *startup) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 33)
	s.fieldMap["id"] = s.ID
	s.fieldMap["comer_id"] = s.ComerID
	s.fieldMap["name"] = s.Name
	s.fieldMap["mode"] = s.Mode
	s.fieldMap["logo"] = s.Logo
	s.fieldMap["cover"] = s.Cover
	s.fieldMap["mission"] = s.Mission
	s.fieldMap["token_contract_address"] = s.TokenContractAddress
	s.fieldMap["overview"] = s.Overview
	s.fieldMap["tx_hash"] = s.TxHash
	s.fieldMap["on_chain"] = s.OnChain
	s.fieldMap["kyc"] = s.Kyc
	s.fieldMap["contract_audit"] = s.ContractAudit
	s.fieldMap["website"] = s.Website
	s.fieldMap["discord"] = s.Discord
	s.fieldMap["twitter"] = s.Twitter
	s.fieldMap["telegram"] = s.Telegram
	s.fieldMap["docs"] = s.Docs
	s.fieldMap["email"] = s.Email
	s.fieldMap["facebook"] = s.Facebook
	s.fieldMap["medium"] = s.Medium
	s.fieldMap["linktree"] = s.Linktree
	s.fieldMap["launch_network"] = s.LaunchNetwork
	s.fieldMap["token_name"] = s.TokenName
	s.fieldMap["token_symbol"] = s.TokenSymbol
	s.fieldMap["total_supply"] = s.TotalSupply
	s.fieldMap["presale_start"] = s.PresaleStart
	s.fieldMap["presale_end"] = s.PresaleEnd
	s.fieldMap["launch_date"] = s.LaunchDate
	s.fieldMap["tab_sequence"] = s.TabSequence
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
	s.fieldMap["is_deleted"] = s.IsDeleted
}

func (s startup) clone(db *gorm.DB) startup {
	s.startupDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s startup) replaceDB(db *gorm.DB) startup {
	s.startupDo.ReplaceDB(db)
	return s
}

type startupDo struct{ gen.DO }

type IStartupDo interface {
	gen.SubQuery
	Debug() IStartupDo
	WithContext(ctx context.Context) IStartupDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IStartupDo
	WriteDB() IStartupDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IStartupDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IStartupDo
	Not(conds ...gen.Condition) IStartupDo
	Or(conds ...gen.Condition) IStartupDo
	Select(conds ...field.Expr) IStartupDo
	Where(conds ...gen.Condition) IStartupDo
	Order(conds ...field.Expr) IStartupDo
	Distinct(cols ...field.Expr) IStartupDo
	Omit(cols ...field.Expr) IStartupDo
	Join(table schema.Tabler, on ...field.Expr) IStartupDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IStartupDo
	RightJoin(table schema.Tabler, on ...field.Expr) IStartupDo
	Group(cols ...field.Expr) IStartupDo
	Having(conds ...gen.Condition) IStartupDo
	Limit(limit int) IStartupDo
	Offset(offset int) IStartupDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IStartupDo
	Unscoped() IStartupDo
	Create(values ...*model.Startup) error
	CreateInBatches(values []*model.Startup, batchSize int) error
	Save(values ...*model.Startup) error
	First() (*model.Startup, error)
	Take() (*model.Startup, error)
	Last() (*model.Startup, error)
	Find() ([]*model.Startup, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Startup, err error)
	FindInBatches(result *[]*model.Startup, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Startup) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IStartupDo
	Assign(attrs ...field.AssignExpr) IStartupDo
	Joins(fields ...field.RelationField) IStartupDo
	Preload(fields ...field.RelationField) IStartupDo
	FirstOrInit() (*model.Startup, error)
	FirstOrCreate() (*model.Startup, error)
	FindByPage(offset int, limit int) (result []*model.Startup, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IStartupDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s startupDo) Debug() IStartupDo {
	return s.withDO(s.DO.Debug())
}

func (s startupDo) WithContext(ctx context.Context) IStartupDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s startupDo) ReadDB() IStartupDo {
	return s.Clauses(dbresolver.Read)
}

func (s startupDo) WriteDB() IStartupDo {
	return s.Clauses(dbresolver.Write)
}

func (s startupDo) Session(config *gorm.Session) IStartupDo {
	return s.withDO(s.DO.Session(config))
}

func (s startupDo) Clauses(conds ...clause.Expression) IStartupDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s startupDo) Returning(value interface{}, columns ...string) IStartupDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s startupDo) Not(conds ...gen.Condition) IStartupDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s startupDo) Or(conds ...gen.Condition) IStartupDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s startupDo) Select(conds ...field.Expr) IStartupDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s startupDo) Where(conds ...gen.Condition) IStartupDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s startupDo) Order(conds ...field.Expr) IStartupDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s startupDo) Distinct(cols ...field.Expr) IStartupDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s startupDo) Omit(cols ...field.Expr) IStartupDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s startupDo) Join(table schema.Tabler, on ...field.Expr) IStartupDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s startupDo) LeftJoin(table schema.Tabler, on ...field.Expr) IStartupDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s startupDo) RightJoin(table schema.Tabler, on ...field.Expr) IStartupDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s startupDo) Group(cols ...field.Expr) IStartupDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s startupDo) Having(conds ...gen.Condition) IStartupDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s startupDo) Limit(limit int) IStartupDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s startupDo) Offset(offset int) IStartupDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s startupDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IStartupDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s startupDo) Unscoped() IStartupDo {
	return s.withDO(s.DO.Unscoped())
}

func (s startupDo) Create(values ...*model.Startup) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s startupDo) CreateInBatches(values []*model.Startup, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s startupDo) Save(values ...*model.Startup) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s startupDo) First() (*model.Startup, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Startup), nil
	}
}

func (s startupDo) Take() (*model.Startup, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Startup), nil
	}
}

func (s startupDo) Last() (*model.Startup, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Startup), nil
	}
}

func (s startupDo) Find() ([]*model.Startup, error) {
	result, err := s.DO.Find()
	return result.([]*model.Startup), err
}

func (s startupDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Startup, err error) {
	buf := make([]*model.Startup, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s startupDo) FindInBatches(result *[]*model.Startup, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s startupDo) Attrs(attrs ...field.AssignExpr) IStartupDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s startupDo) Assign(attrs ...field.AssignExpr) IStartupDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s startupDo) Joins(fields ...field.RelationField) IStartupDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s startupDo) Preload(fields ...field.RelationField) IStartupDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s startupDo) FirstOrInit() (*model.Startup, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Startup), nil
	}
}

func (s startupDo) FirstOrCreate() (*model.Startup, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Startup), nil
	}
}

func (s startupDo) FindByPage(offset int, limit int) (result []*model.Startup, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s startupDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s startupDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s startupDo) Delete(models ...*model.Startup) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *startupDo) withDO(do gen.Dao) *startupDo {
	s.DO = *do.(*gen.DO)
	return s
}
