// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package metaland

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"greet/data/model"
)

func newCrowdfunding(db *gorm.DB, opts ...gen.DOOption) crowdfunding {
	_crowdfunding := crowdfunding{}

	_crowdfunding.crowdfundingDo.UseDB(db, opts...)
	_crowdfunding.crowdfundingDo.UseModel(&model.Crowdfunding{})

	tableName := _crowdfunding.crowdfundingDo.TableName()
	_crowdfunding.ALL = field.NewAsterisk(tableName)
	_crowdfunding.ID = field.NewInt64(tableName, "id")
	_crowdfunding.ChainID = field.NewInt64(tableName, "chain_id")
	_crowdfunding.TxHash = field.NewString(tableName, "tx_hash")
	_crowdfunding.CrowdfundingContract = field.NewString(tableName, "crowdfunding_contract")
	_crowdfunding.StartupID = field.NewInt64(tableName, "startup_id")
	_crowdfunding.ComerID = field.NewInt64(tableName, "comer_id")
	_crowdfunding.RaiseGoal = field.NewFloat64(tableName, "raise_goal")
	_crowdfunding.RaiseBalance = field.NewFloat64(tableName, "raise_balance")
	_crowdfunding.SellTokenContract = field.NewString(tableName, "sell_token_contract")
	_crowdfunding.SellTokenName = field.NewString(tableName, "sell_token_name")
	_crowdfunding.SellTokenSymbol = field.NewString(tableName, "sell_token_symbol")
	_crowdfunding.SellTokenDecimals = field.NewInt32(tableName, "sell_token_decimals")
	_crowdfunding.SellTokenSupply = field.NewFloat64(tableName, "sell_token_supply")
	_crowdfunding.SellTokenDeposit = field.NewFloat64(tableName, "sell_token_deposit")
	_crowdfunding.SellTokenBalance = field.NewFloat64(tableName, "sell_token_balance")
	_crowdfunding.BuyTokenContract = field.NewString(tableName, "buy_token_contract")
	_crowdfunding.BuyTokenName = field.NewString(tableName, "buy_token_name")
	_crowdfunding.BuyTokenSymbol = field.NewString(tableName, "buy_token_symbol")
	_crowdfunding.BuyTokenDecimals = field.NewInt32(tableName, "buy_token_decimals")
	_crowdfunding.BuyTokenSupply = field.NewFloat64(tableName, "buy_token_supply")
	_crowdfunding.TeamWallet = field.NewString(tableName, "team_wallet")
	_crowdfunding.SwapPercent = field.NewFloat32(tableName, "swap_percent")
	_crowdfunding.BuyPrice = field.NewFloat64(tableName, "buy_price")
	_crowdfunding.MaxBuyAmount = field.NewFloat64(tableName, "max_buy_amount")
	_crowdfunding.MaxSellPercent = field.NewFloat32(tableName, "max_sell_percent")
	_crowdfunding.SellTax = field.NewFloat32(tableName, "sell_tax")
	_crowdfunding.StartTime = field.NewTime(tableName, "start_time")
	_crowdfunding.EndTime = field.NewTime(tableName, "end_time")
	_crowdfunding.Poster = field.NewString(tableName, "poster")
	_crowdfunding.Youtube = field.NewString(tableName, "youtube")
	_crowdfunding.Detail = field.NewString(tableName, "detail")
	_crowdfunding.Description = field.NewString(tableName, "description")
	_crowdfunding.Status = field.NewBool(tableName, "status")
	_crowdfunding.CreatedAt = field.NewTime(tableName, "created_at")
	_crowdfunding.UpdatedAt = field.NewTime(tableName, "updated_at")
	_crowdfunding.IsDeleted = field.NewBool(tableName, "is_deleted")

	_crowdfunding.fillFieldMap()

	return _crowdfunding
}

type crowdfunding struct {
	crowdfundingDo

	ALL                  field.Asterisk
	ID                   field.Int64   // crowdfunding id
	ChainID              field.Int64   // Chain id
	TxHash               field.String  // Tx hash
	CrowdfundingContract field.String  // Crowdfunding contract address
	StartupID            field.Int64   // Startup id
	ComerID              field.Int64   // Founder's comer id
	RaiseGoal            field.Float64 // Raise goal total
	RaiseBalance         field.Float64 // Raise token balance
	SellTokenContract    field.String  // Sell token contract address
	SellTokenName        field.String  // Sell token name
	SellTokenSymbol      field.String  // Sell token symbol
	SellTokenDecimals    field.Int32   // Sell token decimals
	SellTokenSupply      field.Float64 // Sell token total supply
	SellTokenDeposit     field.Float64 // Sell token deposit
	SellTokenBalance     field.Float64 // Sell token balance
	BuyTokenContract     field.String  // Buy token contract address
	BuyTokenName         field.String  // Buy token name
	BuyTokenSymbol       field.String  // Buy token symbol
	BuyTokenDecimals     field.Int32   // Buy token decimals
	BuyTokenSupply       field.Float64 // Buy token total supply
	TeamWallet           field.String  // Team wallet address
	SwapPercent          field.Float32 // Swap percent
	BuyPrice             field.Float64 // IBO rate
	MaxBuyAmount         field.Float64 // Maximum buy amount
	MaxSellPercent       field.Float32 // Maximum selling percent
	SellTax              field.Float32 // Selling tax
	StartTime            field.Time    // Start time
	EndTime              field.Time    // End time
	Poster               field.String  // Poster url
	Youtube              field.String  // Youtube link
	Detail               field.String  // Detail url
	Description          field.String  // Description content
	Status               field.Bool    // 0:Pending 1:Upcoming 2:Live 3:Ended 4:Cancelled 5:Failure
	CreatedAt            field.Time
	UpdatedAt            field.Time
	IsDeleted            field.Bool // Is deleted

	fieldMap map[string]field.Expr
}

func (c crowdfunding) Table(newTableName string) *crowdfunding {
	c.crowdfundingDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c crowdfunding) As(alias string) *crowdfunding {
	c.crowdfundingDo.DO = *(c.crowdfundingDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *crowdfunding) updateTableName(table string) *crowdfunding {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewInt64(table, "id")
	c.ChainID = field.NewInt64(table, "chain_id")
	c.TxHash = field.NewString(table, "tx_hash")
	c.CrowdfundingContract = field.NewString(table, "crowdfunding_contract")
	c.StartupID = field.NewInt64(table, "startup_id")
	c.ComerID = field.NewInt64(table, "comer_id")
	c.RaiseGoal = field.NewFloat64(table, "raise_goal")
	c.RaiseBalance = field.NewFloat64(table, "raise_balance")
	c.SellTokenContract = field.NewString(table, "sell_token_contract")
	c.SellTokenName = field.NewString(table, "sell_token_name")
	c.SellTokenSymbol = field.NewString(table, "sell_token_symbol")
	c.SellTokenDecimals = field.NewInt32(table, "sell_token_decimals")
	c.SellTokenSupply = field.NewFloat64(table, "sell_token_supply")
	c.SellTokenDeposit = field.NewFloat64(table, "sell_token_deposit")
	c.SellTokenBalance = field.NewFloat64(table, "sell_token_balance")
	c.BuyTokenContract = field.NewString(table, "buy_token_contract")
	c.BuyTokenName = field.NewString(table, "buy_token_name")
	c.BuyTokenSymbol = field.NewString(table, "buy_token_symbol")
	c.BuyTokenDecimals = field.NewInt32(table, "buy_token_decimals")
	c.BuyTokenSupply = field.NewFloat64(table, "buy_token_supply")
	c.TeamWallet = field.NewString(table, "team_wallet")
	c.SwapPercent = field.NewFloat32(table, "swap_percent")
	c.BuyPrice = field.NewFloat64(table, "buy_price")
	c.MaxBuyAmount = field.NewFloat64(table, "max_buy_amount")
	c.MaxSellPercent = field.NewFloat32(table, "max_sell_percent")
	c.SellTax = field.NewFloat32(table, "sell_tax")
	c.StartTime = field.NewTime(table, "start_time")
	c.EndTime = field.NewTime(table, "end_time")
	c.Poster = field.NewString(table, "poster")
	c.Youtube = field.NewString(table, "youtube")
	c.Detail = field.NewString(table, "detail")
	c.Description = field.NewString(table, "description")
	c.Status = field.NewBool(table, "status")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.IsDeleted = field.NewBool(table, "is_deleted")

	c.fillFieldMap()

	return c
}

func (c *crowdfunding) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *crowdfunding) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 36)
	c.fieldMap["id"] = c.ID
	c.fieldMap["chain_id"] = c.ChainID
	c.fieldMap["tx_hash"] = c.TxHash
	c.fieldMap["crowdfunding_contract"] = c.CrowdfundingContract
	c.fieldMap["startup_id"] = c.StartupID
	c.fieldMap["comer_id"] = c.ComerID
	c.fieldMap["raise_goal"] = c.RaiseGoal
	c.fieldMap["raise_balance"] = c.RaiseBalance
	c.fieldMap["sell_token_contract"] = c.SellTokenContract
	c.fieldMap["sell_token_name"] = c.SellTokenName
	c.fieldMap["sell_token_symbol"] = c.SellTokenSymbol
	c.fieldMap["sell_token_decimals"] = c.SellTokenDecimals
	c.fieldMap["sell_token_supply"] = c.SellTokenSupply
	c.fieldMap["sell_token_deposit"] = c.SellTokenDeposit
	c.fieldMap["sell_token_balance"] = c.SellTokenBalance
	c.fieldMap["buy_token_contract"] = c.BuyTokenContract
	c.fieldMap["buy_token_name"] = c.BuyTokenName
	c.fieldMap["buy_token_symbol"] = c.BuyTokenSymbol
	c.fieldMap["buy_token_decimals"] = c.BuyTokenDecimals
	c.fieldMap["buy_token_supply"] = c.BuyTokenSupply
	c.fieldMap["team_wallet"] = c.TeamWallet
	c.fieldMap["swap_percent"] = c.SwapPercent
	c.fieldMap["buy_price"] = c.BuyPrice
	c.fieldMap["max_buy_amount"] = c.MaxBuyAmount
	c.fieldMap["max_sell_percent"] = c.MaxSellPercent
	c.fieldMap["sell_tax"] = c.SellTax
	c.fieldMap["start_time"] = c.StartTime
	c.fieldMap["end_time"] = c.EndTime
	c.fieldMap["poster"] = c.Poster
	c.fieldMap["youtube"] = c.Youtube
	c.fieldMap["detail"] = c.Detail
	c.fieldMap["description"] = c.Description
	c.fieldMap["status"] = c.Status
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["is_deleted"] = c.IsDeleted
}

func (c crowdfunding) clone(db *gorm.DB) crowdfunding {
	c.crowdfundingDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c crowdfunding) replaceDB(db *gorm.DB) crowdfunding {
	c.crowdfundingDo.ReplaceDB(db)
	return c
}

type crowdfundingDo struct{ gen.DO }

type ICrowdfundingDo interface {
	gen.SubQuery
	Debug() ICrowdfundingDo
	WithContext(ctx context.Context) ICrowdfundingDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICrowdfundingDo
	WriteDB() ICrowdfundingDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICrowdfundingDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICrowdfundingDo
	Not(conds ...gen.Condition) ICrowdfundingDo
	Or(conds ...gen.Condition) ICrowdfundingDo
	Select(conds ...field.Expr) ICrowdfundingDo
	Where(conds ...gen.Condition) ICrowdfundingDo
	Order(conds ...field.Expr) ICrowdfundingDo
	Distinct(cols ...field.Expr) ICrowdfundingDo
	Omit(cols ...field.Expr) ICrowdfundingDo
	Join(table schema.Tabler, on ...field.Expr) ICrowdfundingDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICrowdfundingDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICrowdfundingDo
	Group(cols ...field.Expr) ICrowdfundingDo
	Having(conds ...gen.Condition) ICrowdfundingDo
	Limit(limit int) ICrowdfundingDo
	Offset(offset int) ICrowdfundingDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICrowdfundingDo
	Unscoped() ICrowdfundingDo
	Create(values ...*model.Crowdfunding) error
	CreateInBatches(values []*model.Crowdfunding, batchSize int) error
	Save(values ...*model.Crowdfunding) error
	First() (*model.Crowdfunding, error)
	Take() (*model.Crowdfunding, error)
	Last() (*model.Crowdfunding, error)
	Find() ([]*model.Crowdfunding, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Crowdfunding, err error)
	FindInBatches(result *[]*model.Crowdfunding, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Crowdfunding) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICrowdfundingDo
	Assign(attrs ...field.AssignExpr) ICrowdfundingDo
	Joins(fields ...field.RelationField) ICrowdfundingDo
	Preload(fields ...field.RelationField) ICrowdfundingDo
	FirstOrInit() (*model.Crowdfunding, error)
	FirstOrCreate() (*model.Crowdfunding, error)
	FindByPage(offset int, limit int) (result []*model.Crowdfunding, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICrowdfundingDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c crowdfundingDo) Debug() ICrowdfundingDo {
	return c.withDO(c.DO.Debug())
}

func (c crowdfundingDo) WithContext(ctx context.Context) ICrowdfundingDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c crowdfundingDo) ReadDB() ICrowdfundingDo {
	return c.Clauses(dbresolver.Read)
}

func (c crowdfundingDo) WriteDB() ICrowdfundingDo {
	return c.Clauses(dbresolver.Write)
}

func (c crowdfundingDo) Session(config *gorm.Session) ICrowdfundingDo {
	return c.withDO(c.DO.Session(config))
}

func (c crowdfundingDo) Clauses(conds ...clause.Expression) ICrowdfundingDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c crowdfundingDo) Returning(value interface{}, columns ...string) ICrowdfundingDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c crowdfundingDo) Not(conds ...gen.Condition) ICrowdfundingDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c crowdfundingDo) Or(conds ...gen.Condition) ICrowdfundingDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c crowdfundingDo) Select(conds ...field.Expr) ICrowdfundingDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c crowdfundingDo) Where(conds ...gen.Condition) ICrowdfundingDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c crowdfundingDo) Order(conds ...field.Expr) ICrowdfundingDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c crowdfundingDo) Distinct(cols ...field.Expr) ICrowdfundingDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c crowdfundingDo) Omit(cols ...field.Expr) ICrowdfundingDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c crowdfundingDo) Join(table schema.Tabler, on ...field.Expr) ICrowdfundingDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c crowdfundingDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICrowdfundingDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c crowdfundingDo) RightJoin(table schema.Tabler, on ...field.Expr) ICrowdfundingDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c crowdfundingDo) Group(cols ...field.Expr) ICrowdfundingDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c crowdfundingDo) Having(conds ...gen.Condition) ICrowdfundingDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c crowdfundingDo) Limit(limit int) ICrowdfundingDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c crowdfundingDo) Offset(offset int) ICrowdfundingDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c crowdfundingDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICrowdfundingDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c crowdfundingDo) Unscoped() ICrowdfundingDo {
	return c.withDO(c.DO.Unscoped())
}

func (c crowdfundingDo) Create(values ...*model.Crowdfunding) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c crowdfundingDo) CreateInBatches(values []*model.Crowdfunding, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c crowdfundingDo) Save(values ...*model.Crowdfunding) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c crowdfundingDo) First() (*model.Crowdfunding, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Crowdfunding), nil
	}
}

func (c crowdfundingDo) Take() (*model.Crowdfunding, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Crowdfunding), nil
	}
}

func (c crowdfundingDo) Last() (*model.Crowdfunding, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Crowdfunding), nil
	}
}

func (c crowdfundingDo) Find() ([]*model.Crowdfunding, error) {
	result, err := c.DO.Find()
	return result.([]*model.Crowdfunding), err
}

func (c crowdfundingDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Crowdfunding, err error) {
	buf := make([]*model.Crowdfunding, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c crowdfundingDo) FindInBatches(result *[]*model.Crowdfunding, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c crowdfundingDo) Attrs(attrs ...field.AssignExpr) ICrowdfundingDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c crowdfundingDo) Assign(attrs ...field.AssignExpr) ICrowdfundingDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c crowdfundingDo) Joins(fields ...field.RelationField) ICrowdfundingDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c crowdfundingDo) Preload(fields ...field.RelationField) ICrowdfundingDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c crowdfundingDo) FirstOrInit() (*model.Crowdfunding, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Crowdfunding), nil
	}
}

func (c crowdfundingDo) FirstOrCreate() (*model.Crowdfunding, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Crowdfunding), nil
	}
}

func (c crowdfundingDo) FindByPage(offset int, limit int) (result []*model.Crowdfunding, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c crowdfundingDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c crowdfundingDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c crowdfundingDo) Delete(models ...*model.Crowdfunding) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *crowdfundingDo) withDO(do gen.Dao) *crowdfundingDo {
	c.DO = *do.(*gen.DO)
	return c
}
