
假设你有一个专门用来管理你所持有的 NFT 的合约，可能需要记录你持有的每个 NFT 及其对应的 ID。为了实现这一目的，你可能会考虑像下面的示例一样，定义多个 uint 变量来记录每个 NFT 的 ID：

```
uint nftID1 = 1001;
uint nftID2 = 1002;
uint nftID3 = 1003;
uint nftID4 = 1004;
...
```

![](static/VezhbnhaNofEdRx6N0QcAho1nKu.png)

上面的示例中，我们定义了 4 个 uint 变量，用于记录 4 个 NFT ID。但是假设你是 NFT 持有大户，手上有上万个 NFT，这种方法就不太实用了。如果按照这种方式，我们需要定义上万个 uint 变量来记录每个 NFT 的 ID，这显然是不太现实的。这种方法存在两个主要问题：

1. 定义太多变量会变得麻烦，难以维护。
2. 能够记录的 NFT ID 数量是固定的，一旦合约部署完成，就无法增加新的 NFT。

在面对这种情况时，数组（array）就显得非常有用了

## 数组的声明

数组是一种数据结构，用于存储同类型元素的有序集合。根据数组长度是否可以改变，可以将数组分为以下两种类型：

- 静态数组（Static Array）
- 动态数组（Dynamic Array）

### 静态数组的声明

假设 `T` 是一种类型，那么静态数组的声明格式如下：

```
T[arrSize] DataLocation arrName;
```

其中，`arrSize` 表示数组的长度，`DataLocation` 表示数据位置，而 `arrName` 则是你为这个数组取的任意名字。

数组是一种引用类型。请注意：在声明和定义数组时，必须使用三个数据位置关键字之一：`storage`、`memory`、`calldata`。

声明静态数组

```
uint[3] memory nftMem;
uint[3] storage nftStorage;
```

在 Solidity 中，需要注意静态数组的大小必须在编译时确定。这意味着你不能使用变量来指定数组的大小。举例来说，下面的代码是不合法的：

```
uint size = 2;
uint[size][size] memory array; _// 非法，size 是变量，不能用来指定数组大小_
```

### 动态数组的声明

假设 `T` 是一种类型，那么动态数组的声明格式如下：

```
T[] DataLocation arrName;
```

其中 `DataLocation` 是数据位置，而 `arrName` 是你为这个数组起的任意名字。

声明动态数组

```
uint[] memory nftMem;
uint[] storage nftStorage;
```

## 数组的初始化

静态数组的初始化和动态数组的初始化不太一样，我们分开来讨论。

### 静态数组的初始化

#### 零值初始化

若你只声明了静态数组但未手动进行初始化，那么数组中的所有元素都会被零值初始化。这意味着所有元素都会被赋予默认值。

零值初始化整型数组

```
uint[3] memory nftArr; _//所有元素都是0_
```

#### 数组字面值初始化

你可以使用数组字面值对静态数组进行初始化。数组字面值的格式是 [...]，例如 [1, 2, 3] 或 ['str1', 'str2', 'str3']。在下面的例子中，我们使用数组字面值初始化了一个整型数组。

```
_//必须使用uint(1000)显式地将「数组字面值」第一个元素的类型转换成uint_
uint[3] memory nftArr = [uint(1000), 1001, 1002];
```

需要注意的是，数组字面值的基础类型是由其第一个元素的类型确定的。例如，在上面的例子中，[uint(1000), 1001, 1002] 的基础类型是 uint，因为第一个元素是 uint(1000)。其他所有元素都会隐式地被转换成第一个元素的类型。

如果我们不强制将第一个元素转换成与我们所定义的数组的基础类型（在上面的例子中是 uint ）相同，那么编译器会报错。如下面的示例所示：

```
_// 编译报错，类型不匹配_
uint[3] memory nftArr = [1000, 1001, 1002];
```

另外需要注意的一点是，定义的数组长度必须与数组字面值的长度相匹配，否则会导致编译错误。如下面的例子所示：

数组定义的长度为 3，但是数组字面值的长度为 2

```
uint[3] memory nftArr = [uint(1000), 1001];  _//编译错误，长度不匹配_
```

### 动态数组初始化


动态数组的初始化需要使用关键字 `new`。它的所有元素值会被「零值初始化」，即赋予默认值。以下是一个整型动态数组的初始化示例：

动态数组初始化

初始化了一个有三个元素的动态数组，元素值被初始化为零值

```
uint n = 3;
uint[] memory nftArr = new uint[](n);
```

使用 `new` 关键字可以在任何数据位置创建动态数组。如果你的动态数组是在 storage 中声明的，你也可以使用数组字面值来初始化：

在 `storage` 的动态数组可以用数组字面值初始化

```
uint[] storageArr = [uint(1), 2]; _// 动态数组只有在storage位置才能用数组字面值初始化_
```

## 静态数组和动态数组是不同的类型

需要注意的是，静态数组和动态数组是不同的类型，因此它们之间不能相互赋值。例如：

不能把静态数组赋值给动态数组：

```
uint[2] memory staticArr = [uint(1), 2];
uint[] memory dynamicArr = staticArr; _// 编译错误，静态数组和动态数组是不同的类型_
```

也不能把动态数组赋值给静态数组：

```
uint[] memory dynamicArr = new uint[](2); 
uint[2] memory staticArr = dynamicArr; _// 编译错误，静态数组和动态数组是不同的类型_
```

## 下标访问

与许多其他编程语言一样，你也可以使用下标访问 Solidity 中的数组。下标访问所使用的操作符是 []，并且下标索引从 0 开始。

数组的下标访问

下标访问静态数组：

```
uint[3] memory nftArr1 = [uint(1000), 1001, 1002];
nftArr1[0] = 2000;
nftArr1[1] = 2001;
nftArr1[2] = 2002;
```

下标访问动态数组：

```
uint[] memory nftArr2 = new uint[](n);
nftArr2[0] = 1000;
nftArr2[1] = 1001;
nftArr2[2] = 1002;
```
