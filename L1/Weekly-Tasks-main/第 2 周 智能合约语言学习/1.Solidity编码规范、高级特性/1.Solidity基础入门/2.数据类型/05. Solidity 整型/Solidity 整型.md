
整型（integer）是不包含小数部分的数值型数据，包括正整数、负整数和 0 等。账户余额、Gas、持有的 Token 数量等通常都用整型表示。在 Solidity 中，整型有两种类型：

- intM：有符号整型
- uintM：无符号整型

其中，M 的取值范围为 8 到 256，步长为 8。例如，有 `int8`、`int16`、`int32` 等等，一直到 `int256`。相应地，也有 `uint8`、`uint16`、`uint32`，一直到 `uint256`。其中，`int8` 和 `uint8` 占用 8 位（8 bits），`int16` 和 `uint16` 占用 16 位，以此类推。

## 运算符

### 算术运算符

算术运算符可以用来进行四则运算，得到的结果是整型。

- `+`（加）
- `-`（减）
- `*`（乘）
- `/`（除）
- `%`（取模）
- `**`（幂）
- `<<`（左移）
- `>>`（右移）

算术运算

```
假设a=5 , b=2  类型均为uint8

a+b  : 7
a-b  : 3
a*b  : 10
a/b  : 2
a%b  : 1
a**b : 25
a<<b : 20
a>>b : 1
```

### 比较运算符

通过比较运算符，我们可以比较两个变量的数量大小关系，以及变量是否相等。比较运算符得到的结果是布尔值。

- `<=`（小于等于）
- `<` （小于）
- `==`（等于）
- `!=`（不等于）
- `>=`（大于等于）
- `>` （大于）

比较运算

```
假设a=5 , b=2  类型均为uint8

a<=b : false
a<b  : false
a==b : false
a!=b : true
a=b : true
a>b  : true
```

### 位运算符

位运算符用来对二进制位进行操作，其执行结果是整型。

- `&`（按位与）
- `|`（按位或）
- `^`（按位异或）
- `~`（按位取反）

位运算

```
假设a=5 , b=2  类型均为uint8

a&b : 0
a|b : 7
a^b : 7
~a  : 250
```

## 整型溢出

Solidity 中的整型运算可能会出现溢出的情况，导致合约运行时产生不符合预期的行为。在旧版本的 Solidity 中，你可能会使用 OpenZeppelin 的 SafeMath 库来防止整型溢出。然而，在 Solidity 0.8.0 及以上版本中，一旦出现整型溢出，整个交易都会被终止。因此，在这些版本中，Solidity 在处理整型溢出方面是安全的。

例如，`uint8` 能够储存的最大正整数为 255。如果再加 1，就会发生整型溢出。执行以下函数时，Remix Terminal 会输出：`call to Integer.overflow errored: VM error: revert`，这意味着整个交易已被回滚。

整型溢出

```
_// SPDX-License-Identifier: GPL-3.0_

pragma solidity ^0.8.17;

contract Integer {
    function overflow() public view {
        uint8 a = 255;
        a = a+1; _//整型溢出，整个transaction revert_
        console.log("a=%s", a);
    }
}
```

我们所说的整型溢出是安全的，指的是一旦发生整型溢出，整个交易都会被终止，就像什么事都没发生一样。然而，这并不意味着你的合约就完全没有问题，你仍需要注意其他的潜在风险。例如，在遍历数组时，如果 `uint` 类型的下标意外地变成了-1，这可能会导致合约出现拒绝服务（denial of service）的问题。因此，即使在防止整型溢出的情况下，仍然需要小心处理代码中的其他逻辑错误。

## 小结

1. Solidity 有两种整型：有符号整型 (intM) 和无符号整型 (uintM)，其中 M 的取值范围为 8 到 256，步长为 8。
2. 我们介绍了整型可以使用的算术运算符、比较运算符和位运算符。
3. Solidity 的整型运算可能会出现溢出的情况。
4. 在版本 <0.8.0 的 Solidity 中，可以使用 OpenZeppelin 的 SafeMath 库来防止整型溢出。
5. 在版本 >=0.8.0 的 Solidity 中，如果整型溢出，交易会被终止。
6. 虽然 Solidity 在整型溢出方面是安全的，但这并不意味着你的合约没有问题，还需要注意其他的潜在风险。
